## 股票问题1（简单）
### 问题来源
https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/

### 问题描述
>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
>
>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
>
>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

**示例 1：**
> 输入：[7,1,5,3,6,4]  
输出：5  
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
>
>注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。

**示例 2：**
>输入：prices = [7,6,4,3,1]
输出：0  
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
 

**提示：**
> 1 <= prices.length <= 105  
0 <= prices[i] <= 104

### 算法描述
假设当前访问的位置为$i(0<=i< N)$, 变量`min`表示0~i-1的最小值；

那么可以得到i位置卖出的情况下，可以得到的收益为$price[i]-min$;

遍历每一个位置都可以得到一个答案，那么这些答案中的最大值就是整体的答案,及 $ans = max(price[i]-min)$,  其中1<=i<=N-1

代码实现
``` java
public static int maxProfit(int[] prices) {
    if (prices == null || prices.length == 0) {
        return 0;
    }
    // 必须在0时刻卖掉，[0] - [0]
    int ans = 0;
    // arr[0...0]
    int min = prices[0];
    for (int i = 1; i < prices.length; i++) {
        min = Math.min(min, prices[i]);
        ans = Math.max(ans, prices[i] - min);
    }
    return ans;
}
```

### 复杂度分析
时间复杂度$O(N)$
空间复杂度$O(1)$

## 股票问题2(中等)
### 问题来源
https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/

### 问题描述
>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。
>
>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。
>
>返回 你能获得的 最大 利润 。

**示例 1：**
>输入：prices = [7,1,5,3,6,4]  
输出：7  
解释：  
在第 2 天（股票价格 = 1）的时候买入，  
在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。  
随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。  
总利润为 4 + 3 = 7 。

**示例 2：**
> 输入：prices = [1,2,3,4,5]  
输出：4  
解释：在第 1 天（股票价格 = 1）的时候买入，  
在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
总利润为 4 。

**示例 3：**
>输入：prices = [7,6,4,3,1]  
输出：0  
解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。

**提示：**
- 1 <= prices.length <= 3 * 104
- 0 <= prices[i] <= 104

### 问题分析
该问题与问题1的差别是可以买卖多次，但是手里最多只能留一只股票

对于任意i位置（1~N-1）位置， 只要price[i]-price[i-1]是有收益的，就一定可以获得这个收益，如果是没有收益的，就获得0的收益， 所以有

$$ans =\sum_{i=1}^{N-1}max(price[i]-price[i-1], 0)$$

### 算法实现
``` java
public static int maxProfit(int[] prices) {
    if (prices == null || prices.length == 0) {
        return 0;
    }
    int ans = 0;
    for (int i = 1; i < prices.length; i++) {
        ans += Math.max(prices[i] - prices[i-1], 0);
    }
    return ans;
}
```

### 复杂度分析
时间复杂度$O(N)$
空间复杂度$O(1)$

## 股票问题3(中等)
### 问题来源
https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/

### 问题描述
>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。
>
>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。
>
**注意**：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。


**示例 1:**
>输入：prices = [3,3,5,0,0,3,1,4]  
输出：6  
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。  
随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。

**示例 2：**
>输入：prices = [1,2,3,4,5]  
输出：4  
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。  

**注意：你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。**

**示例 3：**
>输入：prices = [7,6,4,3,1]   
输出：0   
解释：在这个情况下, 没有交易完成, 所以最大利润为 0。

**示例 4：**
>输入：prices = [1]  
输出：0
 
**提示：**
>1 <= prices.length <= 105  
0 <= prices[i] <= 105

### 问题分析
该问题是股票问题4的特殊情况，直接看股票问题4即可

## 股票问题4（困难）
### 问题来源
https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/
### 问题描述
>给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。
>
>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。

**注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。**

**示例 1：**
> 输入：k = 2, prices = [2,4,1]  
输出：2  
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。

**示例 2：**
> 输入：k = 2, prices = [3,2,6,5,0,3]  
输出：7  
解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。  
随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。

**提示：**
- 0 <= k <= 100
- 0 <= prices.length <= 1000
- 0 <= prices[i] <= 1000

### 算法分析

数组的总数量是$N$, 考虑K的几种情况：
- $K >= N/2$, 等同于无限次交易
  **解释**：
  数组里最多有N/2次上坡过程，例如[1,2,1,2,1,2]，有3次上坡

- $K < N/2$
  这种情况需要进一步讨论

下面是如何处理 $K < N/2$的情况：

设定$dp[i][j]$表示在$0..i$的范围，不超过$j$次交易，能够获取的最大收益,那么$dp[N-1][K]$就是最终的答案。

接下来就是如何填写这张dp表：
- 第1行，只是用0~0的范围，进行0次交易，收益是0；进行1次交易，收益也是0；直到进行k次交易，收益依然是0

- 第1列，可以进行0次交易，也就是没有交易，收益也都是0

- 考虑任意$i,j$位置，例如$dp[5][4]$
  如果在price[0..5]最多进行4次交易，会有下列几种情况：
  那么最后一次交易一定是在5时刻卖出的。那么最后一次交易是哪里买入的呢？
  - p1: 5位置不参与交易
    可以得到$dp[5][4] = dp[4][4]$
  - p2：5位置参与最后一次交易
    - p2.1 最后一次交易是在5时刻买入的，最后一次交易的收益是0；$dp[5][4] = dp[5][3] + price[5]-price[5]$
    - p2.2：最后一次交易是在4时刻进行的，那么可以得到$dp[5][4] = dp[4][3] + price[5]-price[4]$， 同理可以推出最后一次的买入时机为3时刻，2时刻，1时刻，0时刻

  小结一下,可以得到
  $$
  dp[5][4]^1= dp[4][4], 5位置不参与最后一次交易
  $$

  $$
  dp[5][4]^2=  price[5] + max
  \begin{cases}
  &dp[5][3] -&price[5], &\text 最后一次交易是5时刻买入 \\
  &dp[4][3] -&price[4], &\text 最后一次交易是4时刻买入 \\
  &\vdots &\vdots &\vdots &\vdots \\
  &dp[0][3] -&price[0], &\text 最后一次交易是0时刻买入 \\
  \end{cases}
  $$

  $$
  dp[5][4] = max
  \begin{cases}
  &dp[5][4]^1, &5位置不参与最后一次交易 \\
  &dp[5][4]^2, &5位置参与最后一次交易 \\
  \end{cases}
  $$

  进一步，可以得到$dp[6][4]$的结果为：
  $$
  dp[6][4]^1= dp[5][4], 6位置不参与最后一次交易
  $$
  $$
  dp[6][4]^2= max
  \begin{cases}
  &dp[6][3] + &price[6]-&price[6], &\text 最后一次交易是6时刻买入 \\
  &dp[5][3] + &price[6]-&price[5], &\text 最后一次交易是5时刻买入 \\
  &\vdots &\vdots &\vdots &\vdots \\
  &dp[0][3] + &price[6]-&price[0], &\text 最后一次交易是0时刻买入 \\
  \end{cases}
  $$

  变形一下得到：
  $$
  dp[6][4]^2= price[6] + max
  \begin{cases}
  & dp[6][3]  - &price[6], &\text 最后一次交易是6时刻买入 \\
  & dp[5][3]  - &price[5], &\text 最后一次交易是5时刻买入 \\
  & \vdots      &\vdots &\vdots\\
  &dp[0][3]  - &price[0], &\text 最后一次交易是0时刻买入 \\
  \end{cases}
  $$

  通过观察可以发现，有重复的计算，$dp[6][4]$可以借用$dp[5][4]$的结果

### 代码实现

``` java
	public static int maxProfit(int K, int[] arr) {
		if (arr == null || arr.length == 0 || K < 1) {
			return 0;
		}
		int N = arr.length;
		if (K >= N / 2) {
			return allTrans(arr);
		}
		int[][] dp = new int[N][K + 1];
		// dp[...][0] = 0
		// dp[0][...] = arr[0.0] 0
		for (int j = 1; j <= K; j++) {
			// dp[1][j]
			int p1 = dp[0][j]; //1位置不参与买卖
			int best = Math.max(dp[1][j - 1] - arr[1], dp[0][j - 1] - arr[0]); //1位置参与交易
			dp[1][j] = Math.max(p1, best + arr[1]);
			// dp[1][j] 准备好一些枚举，接下来准备好的枚举
			for (int i = 2; i < N; i++) {
				p1 = dp[i - 1][j]; //i位置不参与买卖
				int newP = dp[i][j - 1] - arr[i]; //最后一次交易是j时刻买入, 更新枚举值部分
				best = Math.max(newP, best);
				dp[i][j] = Math.max(p1, best + arr[i]);
			}
		}
		return dp[N - 1][K];
	}
```

## 股票问题5（hard）

### 问题来源

https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/

### 问题描述
>给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。​
>
>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:
>
>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

**注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。**

 

**示例 1:**
>输入: prices = [1,2,3,0,2]  
输出: 3   
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]

**示例 2:**
>输入: prices = [1]  
输出: 0
 

**提示：**
- 1 <= prices.length <= 5000
- 0 <= prices[i] <= 1000

### 问题分析

**定义指标`buy[i]`:**

`buy[i]`指的是在0...i范围上，最后一次操作是buy动作，这最后一次操作有可能发生在i位置，也可能发生在i之前。

`buy[i]`值的含义是：max{ 所有可能性[之前交易获得的最大收益 - 最后buy动作的收购价格] }

**定义指标`sell[i]`**

sell[i] :0...i范围上，最后一次操作是sell动作，这最后一次操作有可能发生在i位置，也可能发生在之前
sell[i]值的含义：0...i范围上，最后一次动作是sell的情况下，最好的收益

$$
buy[i]=
\begin{cases}
&buy[i-1], &i位置不参与交易\\
&sell[i-2]-arr[i], &i位置进行买入\\
\end{cases}
$$

**解释说明**

如果i位置没有发生buy行为，说明有没有i位置都一样，那么buy[i] = buy[i-1]，这显而易见
如果i位置发生了buy行为, 那么$$buy[i] = sell[i - 2] - prices[i]$$，
因为你想在i位置买的话，你必须保证之前交易行为发生在0...i-2上，
因为如果i-1位置有可能参与交易的话，i位置就要cooldown了，
而且之前交易行为必须以sell结束，你才能buy，而且要保证之前交易尽可能得到最好的利润，
这正好是`sell[i - 2]`所代表的含义，并且根据`buy[i]`的定义，最后一定要  ` -prices[i]`
$$
sell[i]=
\begin{cases}
&sell[i-1], &i位置不参与交易\\
&buy[i-1]+arr[i], &i位置进行卖出\\
\end{cases}
$$
**解释说明**

如果i位置没有发生sell行为，那么sell[i] = sell[i-1]，这显而易见
如果i位置发生了sell行为，那么我们一定要找到 {之前获得尽可能好的收益 - 最后一次的收购价格尽可能低}，
而这正好是buy[i - 1]的含义！之前所有的"尽可能"中，最好的一个！

需要特殊说明一下：这里是`buy[i-1]`,而不是`buy[i-1]`, 这是由问题条件决定的。**你必须在再次购买前出售掉之前的股票**, 第i天买入，i+1天就可以卖出；如果是第i天卖出，则必须要i+2天才能再次买入。

**需要特殊考虑的情况**  
假设数组为 price[]={5,3}  
buy[1]有两种可能  
1）在0位置进行买入，总的收益为-5  
2）在1位置进行买入，之前的收益为0；总的收益为-3  
所以有:
$$buy[1]=max(-price[0], -price[1])$$

sell[1]  
有3中可能性  
1）0位置买，0位置卖，获得收益0  
2）1位置买，1位置卖，获得收益0  
3）0位置买，1位置卖，获得收益price[1]-price[0]  
所以有：
$$sell[1]=max(0, price[1]-price[0])$$

### 算法实现

``` java
	public static int maxProfit2(int[] prices) {
		if (prices.length < 2) {
			return 0;
		}
		int N = prices.length;
		int[] buy = new int[N];
		int[] sell = new int[N];
		// buy[0] 不需要设置  buy[0] = -arr[0]
		// sell[0] = 0
		buy[1] = Math.max(-prices[0], -prices[1]);
		sell[1] = Math.max(0, prices[1] - prices[0]);
		for (int i = 2; i < N; i++) {
			buy[i] = Math.max(buy[i - 1], sell[i - 2] - prices[i]);
			sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i]);
		}
		return sell[N - 1];
	}
```


## 股票交易问题6(中等)
>给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。
>
>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。
>
>返回获得利润的最大值。
>
>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

 

**示例 1：**
>输入：prices = [1, 3, 2, 8, 4, 9], fee = 2  
输出：8
解释：能够达到的最大利润:  
在此处买入 prices[0] = 1  
在此处卖出 prices[3] = 8  
在此处买入 prices[4] = 4  
在此处卖出 prices[5] = 9  
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8

**示例 2：**
>输入：prices = [1,3,7,5,10,3], fee = 3  
输出：6

**提示：**
- 1 <= prices.length <= 5 * 104
- 1 <= prices[i] < 5 * 104
- 0 <= fee < 5 * 104

### 算法实现
``` java
	public static int maxProfit(int[] arr, int fee) {
		if (arr == null || arr.length < 2) {
			return 0;
		}
		int N = arr.length;
		// 0..0   0 -[0] - fee
		int bestbuy = -arr[0] - fee;
		// 0..0  卖  0
		int bestsell = 0;
		for (int i = 1; i < N; i++) {
			// 来到i位置了！
			// 如果在i必须买  收入 - 批发价 - fee
			int curbuy = bestsell - arr[i] - fee;
			// 如果在i必须卖  整体最优（收入 - 良好批发价 - fee）
			int cursell = bestbuy + arr[i];
			bestbuy = Math.max(bestbuy, curbuy);
			bestsell = Math.max(bestsell, cursell);
		}
		return bestsell;
	}
```
